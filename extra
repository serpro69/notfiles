#!/bin/bash

# run google-cloud-cli via docker
function gcloud_wrapper() {
  # Run Google Cloud CLI commands inside a Docker container.
  #
  # Usage:
  #   gcloud_wrapper [--bash-exec] [--mount-docker] [--mount-ssh] [--no-interactive] [--no-tty] [gcloud_command [args...]]
  #   gcloud_wrapper [gcloud_command [args...]] -- [--mount-docker] [--mount-ssh]
  #
  # Options:
  #   --bash-exec    Start an interactive bash shell inside the Docker container.
  #   --mount-docker Mount Docker configuration directory ($HOME/.docker) inside the container.
  #   --mount-ssh    Mount glcoud SSH private/public keys ($HOME/.ssh/gcloud_compute_engine) inside the container.
  #
  # Description:
  #   This function facilitates running Google Cloud CLI commands inside a Docker container
  #   using the 'serpro69/google-cloud-cli' image. It ensures necessary configurations
  #   are mounted and sets a working directory inside the container. By default, it runs
  #   'gcloud' commands; with '--bash-exec', it starts an interactive bash session inside
  #   the container.
  #
  # Docker Mounts:
  #   - /etc/passwd:/etc/passwd                     Host's passwd file is mounted to the container.
  #   - $HOME/.config/gcloud:$HOME/.config/gcloud   Mounts gcloud configuration directory.
  #   - $HOME/.kube:$HOME/.kube                     Mounts kube configuration directory.
  #   - $(pwd):$HOME/workdir                        Mounts current directory on host to container's workdir.
  #
  # Examples:
  #   gcloud_wrapper --mount-docker auth configure-docker europe-north1-docker.pkg.dev
  #     - configure docker authentication with gcloud helper
  #       (see also: https://cloud.google.com/artifact-registry/docs/docker/authentication#gcloud-helper )
  #
  #   gcloud_wrapper --mount-docker compute instances list
  #     - Runs 'gcloud compute instances list' inside the Docker container.
  #
  #   gcloud_wrapper --bash-exec
  #     - Starts an interactive bash session inside the Docker container.

  local docker_cmd=("docker" "run" "--rm" "-u" "$(id -u):$(id -g)"
                    "-v" "/etc/passwd:/etc/passwd"
                    "-v" "${HOME}/.config/gcloud:${HOME}/.config/gcloud" # mount gcloud configuration
                    "-v" "${HOME}/.kube:${HOME}/.kube" # mount kube configuration
                    "-v" "$(pwd):${HOME}/workdir" # mount PWD on the host to a working dir in container
                    "-w" "${HOME}/workdir") # set working directory in the container

  # Docker on MacOS works differently than on Linux and technically runs in a VM
  # In addition, macos has different notion of user details, so mounting '/etc/passwd' makes little sense.
  # So we run the container as root, and mount configs via named docker volumes instead of local dir volume mounts
  if [ "$(uname)" = 'Darwin' ]; then
    docker_cmd=("docker" "run" "--rm"
                    "--mount" "type=volume,src=gcloud_config,dst=/root/.config" # mount gcloud configuration
                    "--mount" "type=volume,src=gcloud_kube,dst=/root/.kube" # mount kube configuration
                    "-v" "/${HOME}/.config/gcloud:/root/.config/gcloud" # mount gcloud configuration
                    "-v" "$(pwd):${HOME}/workdir" # mount PWD on the host to a working dir in container
                    "-w" "${HOME}/workdir") # set working directory in the container
  fi

  # by default use -ti options
  local no_interactive=false
  local no_tty=false

  local image_name="serpro69/google-cloud-cli"

  local bash_mode=false
  local args=()

  # Function to print usage instructions
  function print_usage() {
    echo "Usage:"
    echo "  gcloud_wrapper [--bash-exec] [--mount-docker] [--mount-ssh] [--no-interactive] [--no-tty] [gcloud_command [args...]]"
    echo "  gcloud_wrapper [gcloud_command [args...]] -- [--bash-exec] [--mount-docker] [--mount-ssh]"
    echo ""
    echo "Options:"
    echo "  --bash-exec    Start an interactive bash shell inside the Docker container."
    echo "  --mount-docker Mount Docker configuration directory (\$HOME/.docker) inside the container."
    echo "  --mount-ssh    Mount glcoud SSH private/public keys ($HOME/.ssh/gcloud_compute_engine) inside the container."
    echo ""
    echo "Description:"
    echo "  This function facilitates running Google Cloud CLI commands inside a Docker container"
    echo "  using the 'serpro69/google-cloud-cli' image. It ensures necessary configurations"
    echo "  are mounted and sets a working directory inside the container. By default, it runs"
    echo "  'gcloud' commands; with '--bash-exec', it starts an interactive bash session inside"
    echo "  the container."
    echo ""
    echo "Docker Mounts:"
    echo "  - /etc/passwd:/etc/passwd                       Host's passwd file is mounted to the container."
    echo "  - \$HOME/.config/gcloud:\$HOME/.config/gcloud   Mounts gcloud configuration directory."
    echo "  - \$HOME/.kube:\$HOME/.kube                     Mounts kube configuration directory."
    echo "  - \$(pwd):\${HOME}/workdir                      Mounts current directory on host to container's workdir."
    echo ""
    echo "  - \$HOME/.docker:\${HOME}/.docker               Mounts docker configuration directory (requires '--mount-docker' option)."
    echo ""
    echo "Examples:"
    echo "  gcloud_wrapper --mount-docker auth configure-docker europe-north1-docker.pkg.dev"
    echo "    - configure docker authentication with gcloud helper"
    echo "      (see also: https://cloud.google.com/artifact-registry/docs/docker/authentication#gcloud-helper )"
    echo ""
    echo "  gcloud_wrapper --mount-docker compute instances list"
    echo "    - Runs 'gcloud compute instances list' inside the Docker container."
    echo ""
    echo "  gcloud_wrapper --bash-exec"
    echo "    - Starts an interactive bash session inside the Docker container."
    echo ""
  }

  # Create dirs for local mounts on Linux
  if [ ! "$(uname)" = 'Darwin' ] && [ ! -d "$HOME/.config/gcloud" ]; then
    mkdir "$HOME/.config/gcloud"
    mkdir "$HOME/.kube"
  fi

  # Process arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-interactive)
        no_interactive=true
        shift
        ;;
      --no-tty)
        no_tty=true
        shift
        ;;
      --bash-exec)
        bash_mode=true
        shift
        ;;
      --mount-docker)
        docker_cmd+=("-v" "${HOME}/.docker:${HOME}/.docker")
        shift
        ;;
      --mount-ssh)
        docker_cmd+=("-v" "${HOME}/.ssh/google_compute_engine:${HOME}/.ssh/google_compute_engine")
        docker_cmd+=("-v" "${HOME}/.ssh/google_compute_engine.pub:${HOME}/.ssh/google_compute_engine.pub")
        shift
        ;;
      -hh|--help-msg)
        print_usage
        return 0
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  if [ "$no_interactive" = false ]; then
    docker_cmd+=("-i")
  fi
  if [ "$no_tty" = false ]; then
    docker_cmd+=("-t")
  fi

  # Execute the command based on options
  if $bash_mode; then
    "${docker_cmd[@]}" "${image_name}" "/bin/bash"
  else
    "${docker_cmd[@]}" "${image_name}" "gcloud" "${args[@]}"
  fi
}

function golangci_lint() {
  docker run --rm -v "$(pwd)":/app -w /app golangci/golangci-lint golangci-lint "$@"
}

function mockery() {
  docker run --rm -v "$(pwd)":/src -w /src vektra/mockery "$@"
}

#if $(which cmatrix > /dev/null); then cmatrix; fi
#if $(which cmatrix > /dev/null) && [ "$(echo ${0//-/})" = "zsh" ]; then cmatrix; fi

# add mason.nvim binaries to path to simplify nvim setup and be able to call a binary by name
if [ -d "$HOME/.local/share/nvim/mason/bin" ]; then
  # add it at the end of PATH so it has least precedence
  export PATH="$PATH:$HOME/.local/share/nvim/mason/bin"
fi

# activate 'default' python virtual environment, if available, on darwin
command -v workon >/dev/null && workon | grep -q '^default$' 2>/dev/null && {
  workon default
}

alias vim-orig='NVIM_APPNAME="nvim-orig" nvim'
alias nvim-orig='NVIM_APPNAME="nvim-orig" nvim'
